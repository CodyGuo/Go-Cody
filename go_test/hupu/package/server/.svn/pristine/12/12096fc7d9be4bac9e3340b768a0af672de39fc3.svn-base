#include "stdafx.h"

#include "CWmiDeviceInfo.h"
#include <comutil.h>
#include <Wbemidl.h>
#include <tchar.h>
#include <strsafe.h>
#include <algorithm>
#include <atlconv.h>
#include <ntddndis.h>
#include <WinIoCtl.h>

#pragma comment (lib, "comsuppw.lib")
#pragma comment (lib, "wbemuuid.lib")


// 通过“PNPDeviceID”获取网卡原生MAC地址
 BOOL WMIDoWithPNPDeviceID( const TCHAR *PNPDeviceID, TCHAR *MacAddress, UINT uSize )
{
	TCHAR	DevicePath[MAX_PATH];
	HANDLE	hDeviceFile;	
	BOOL	isOK = FALSE;

	// 生成设备路径名
	StringCchCopy( DevicePath, MAX_PATH, TEXT("\\\\.\\") );
	StringCchCat( DevicePath, MAX_PATH, PNPDeviceID );
	StringCchCat( DevicePath, MAX_PATH, TEXT("#{ad498944-762f-11d0-8dcb-00c04fc3358c}") );

	// 将“PNPDeviceID”中的“\”替换成“#”，以获得真正的设备路径名
	std::replace( DevicePath + 4, DevicePath + 4 + _tcslen(PNPDeviceID), TEXT('\\'), TEXT('#') ); 

	// 获取设备句柄
	hDeviceFile = CreateFile( DevicePath,
		0,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);

	if( hDeviceFile != INVALID_HANDLE_VALUE )
	{	
		ULONG	dwID;
		BYTE	ucData[8];
		DWORD	dwByteRet;		

		// 获取网卡原生MAC地址
		dwID = OID_802_3_PERMANENT_ADDRESS;
		isOK = DeviceIoControl( hDeviceFile, IOCTL_NDIS_QUERY_GLOBAL_STATS, &dwID, sizeof(dwID), ucData, sizeof(ucData), &dwByteRet, NULL );
		if( isOK )
		{	// 将字节数组转换成16进制字符串
				wsprintf(MacAddress,L"%02X-%02X-%02X-%02X-%02X-%02X",ucData[0],ucData[1],ucData[2],ucData[3],
					ucData[4],ucData[5]);
		}

		CloseHandle( hDeviceFile );
	}

	return isOK;
}

 BOOL WMIDoWithHarddiskSerialNumber( TCHAR *SerialNumber, UINT uSize )
{
	UINT	iLen;
	UINT	i;

	iLen = _tcslen( SerialNumber );
	if( iLen == 40 )	// InterfaceType = "IDE"
	{	// 需要将16进制编码串转换为字符串
		TCHAR ch, szBuf[32];
		BYTE b;		

		for( i = 0; i < 20; i++ )
		{	// 将16进制字符转换为高4位
			ch = SerialNumber[i * 2];
			if( (ch >= '0') && (ch <= '9') )
			{
				b = ch - '0';
			}
			else if( (ch >= 'A') && (ch <= 'F') )
			{
				b = ch - 'A' + 10;
			}
			else if( (ch >= 'a') && (ch <= 'f') )
			{
				b = ch - 'a' + 10;
			}
			else
			{	// 非法字符
				break;
			}

			b <<= 4;

			// 将16进制字符转换为低4位
			ch = SerialNumber[i * 2 + 1];
			if( (ch >= '0') && (ch <= '9') )
			{
				b += ch - '0';
			}
			else if( (ch >= 'A') && (ch <= 'F') )
			{
				b += ch - 'A' + 10;
			}
			else if( (ch >= 'a') && (ch <= 'f') )
			{
				b += ch - 'a' + 10;
			}
			else
			{	// 非法字符
				break;
			}

			szBuf[i] = b;
		}

		if( i == 20 )
		{	// 转换成功
			szBuf[i] = L'\0';
			StringCchCopy( SerialNumber, uSize, szBuf );
			iLen = _tcslen( SerialNumber );
		}
	}

	// 每2个字符互换位置
	for( i = 0; i < iLen; i += 2 )
	{
		std::swap( SerialNumber[i], SerialNumber[i+1] );
	}

	// 去掉空格
	std::remove( SerialNumber, SerialNumber + _tcslen(SerialNumber) + 1, L' ' );

	return TRUE;
}

 BOOL WMIDoWithProperty( INT iQueryType, TCHAR *szProperty, UINT uSize )
{
	BOOL isOK = TRUE;

	switch( iQueryType )
	{
		case PERMANENTMAC:	
		isOK = WMIDoWithPNPDeviceID( szProperty, szProperty, uSize );
		break;

	case DISKDRIVESERIAL:		// 硬盘序列号
		isOK = WMIDoWithHarddiskSerialNumber( szProperty, uSize );
		break;

	default:
		// 去掉空格
		std::remove( szProperty, szProperty + _tcslen(szProperty) + 1, L' ' );
	}

	return isOK;
}

 //int WMIDeviceQuery( const T_WQL_QUERY szWQLQuery, QUERYHARDWARETYPE querytype, T_DEVICE_PROPERTY *properties )
 //{
	// 	HRESULT hres;
	//int iTotal = 0;

	//int bfunRes = WMI_QUERYPROPERTY_FAIL;
 //   // 初始化COM

 //   hres = CoInitializeEx( NULL, COINIT_MULTITHREADED ); 
 //   if( FAILED(hres) )
 //   {
	//	return bfunRes;
 //   }

 //    //设置COM的安全认证级别
	//hres = CoInitializeSecurity( 
	//	NULL, 
	//	-1, 
	//	NULL, 
	//	NULL, 
	//	RPC_C_AUTHN_LEVEL_DEFAULT, 
	//	RPC_C_IMP_LEVEL_IMPERSONATE,
 //       NULL,
 //       EOAC_NONE,
 //       NULL
	//	);
	//if( FAILED(hres) )
 //   {
	//	OutputDebugString(L"CoInitializeSecurity Fail");
	//	//MessageBox(NULL,L"CoInitializeSecurity Fail",L"error",0);
 //      // return -2;
 //   }
 //   
	//// 获得WMI连接COM接口
 //   IWbemLocator *pLoc = NULL;
 //   hres = CoCreateInstance( 
	//	CLSID_WbemLocator,             
 //       NULL, 
 //       CLSCTX_INPROC_SERVER, 
 //       IID_IWbemLocator,
	//	reinterpret_cast<LPVOID*>(&pLoc)
	//	); 
 //   if( FAILED(hres) )
 //   {
	//	CoUninitialize();
	//	OutputDebugString(L"CoCreateInstance Fail");
	//	//MessageBox(NULL,L"CoCreateInstance Fail",L"error",0);
 //       return bfunRes;
 //   }

 //   // 通过连接接口连接WMI的内核对象名"ROOT\\CIMV2"
	//IWbemServices *pSvc = NULL;
	//hres = pLoc->ConnectServer(
 //        _bstr_t( L"ROOT\\CIMV2" ),
 //        NULL,
 //        NULL,
 //        NULL,
 //        0,
 //        NULL,
 //        NULL,
 //        &pSvc
	//	 );    
 //   if( FAILED(hres) )
 //   {
	//	pLoc->Release(); 
 //       CoUninitialize();
 //       return bfunRes;
 //   }

	//// 设置请求代理的安全级别
 //   hres = CoSetProxyBlanket(
	//	pSvc,
	//	RPC_C_AUTHN_WINNT,
	//	RPC_C_AUTHZ_NONE,
	//	NULL,
	//	RPC_C_AUTHN_LEVEL_CALL,
	//	RPC_C_IMP_LEVEL_IMPERSONATE,
	//	NULL,
	//	EOAC_NONE
	//	);
	//if( FAILED(hres) )
 //   {
 //       pSvc->Release();
 //       pLoc->Release();     
 //       CoUninitialize();
 //       return bfunRes;
 //   }

	//    // 通过请求代理来向WMI发送请求
 //   IEnumWbemClassObject *pEnumerator = NULL;

	////int iQueryType = 0;
	////for( iQueryType = 0;iQueryType<szWQLQuerySize;iQueryType++)
	////{
	//	
	//	/*	T_DEVICE_PROPERTY properties[10];
	//	memset(properties,0,sizeof(T_DEVICE_PROPERTY));
	//	iTotal = 0;*/

 //   hres = pSvc->ExecQuery(
	//	bstr_t("WQL"), 
	//	bstr_t( /*szWQLQuery[iQueryType].szSelect*/ szWQLQuery.selectstr.c_str()),
 //       WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
 //       NULL,
 //       &pEnumerator
	//	);
	//if( FAILED(hres) )
 //   {
	//	wchar_t  szBuf[128] = {L"0"};
	//	LPVOID lpMsgBuf;
	//	FormatMessage (
	//		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
	//		NULL,
	//		hres,
	//		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
	//		(LPWSTR) &lpMsgBuf,
	//		0, NULL );

	//	wsprintf(szBuf,
	//		L"Next  err (err=%0xd): %s",
	//		hres, lpMsgBuf);
	//	LocalFree(lpMsgBuf);

	//	OutputDebugString(szBuf);

	//	//MessageBox(NULL,szBuf,L"ExecQuery Fail",0);
 //       pSvc->Release();
 //       pLoc->Release();
 //       CoUninitialize();
 //       return -3;
 //   }

 //   // 循环枚举所有的结果对象  
 //   //while( pEnumerator )
 //  // {
	//	IWbemClassObject *pclsObj = NULL;
	//	ULONG uReturn = 0;

	//	/*if( (properties != NULL) && (iTotal >= iSize) )
	//	{
	//		break;
	//	}*/

 //       hres = pEnumerator->Next(
	//		WBEM_INFINITE,
	//		1, 
 //           &pclsObj,
	//		&uReturn
	//		);

 //       if( uReturn == 0 )
 //       {
	//		wchar_t  szBuf[128] = {L"0"};
	//		LPVOID lpMsgBuf;
	//		FormatMessage (
	//			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
	//			NULL,
	//			hres,
	//			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
	//			(LPWSTR) &lpMsgBuf,
	//			0, NULL );

	//		wsprintf(szBuf,
	//			L"Next  err (err=%0xd): %s",
	//			hres, lpMsgBuf);
	//		LocalFree(lpMsgBuf);

	//		OutputDebugString(szBuf);
	//		//MessageBox(NULL,szBuf,L"error",0);

	//		continue;
 //          // break;
 //       }
	//

	//	//if( properties != NULL )
	//	//{	// 获取属性值
	//		VARIANT vtProperty;
	//		
	//		VariantInit( &vtProperty );	
	//		pclsObj->Get( szWQLQuery[iQueryType].szProperty, 0, &vtProperty, NULL, NULL );
	//		StringCchCopy( properties[iQueryType].szProperty, PROPERTY_MAX_LEN, W2T(vtProperty.bstrVal) );
	//		//StringCchCopy( properties[iTotal].szProperty, PROPERTY_MAX_LEN, W2T(vtProperty.bstrVal) );
	//		VariantClear( &vtProperty );

	//		// 对属性值做进一步的处理
	//		if( WMI_DoWithProperty( iQueryType, properties[iQueryType].szProperty, PROPERTY_MAX_LEN ) )
	//		{
	//			iTotal++;
	//		}
	//	//}
	//	//else
	//	//{
	//	//	iTotal++;
	//	//}

	//	pclsObj->Release();
 //  // } // End While
	////}

 //   // 释放资源
	//pEnumerator->Release();
 //   pSvc->Release();
 //   pLoc->Release();    
 //   CoUninitialize();

 //   return iTotal;
 //}

//int WMIDeviceQuery(const T_WQL_QUERY szWQLQuery, QUERYHARDWARETYPE querytype, T_DEVICE_PROPERTY *properties)
//{
//	HRESULT hres;
//	int iTotal = 0;
//
//	int bfunRes = WMI_QUERYPROPERTY_FAIL;
//    // 初始化COM
//
//    hres = CoInitializeEx( NULL, COINIT_MULTITHREADED ); 
//    if( FAILED(hres) )
//    {
//		return bfunRes;
//    }
//
//     //设置COM的安全认证级别
//	hres = CoInitializeSecurity( 
//		NULL, 
//		-1, 
//		NULL, 
//		NULL, 
//		RPC_C_AUTHN_LEVEL_DEFAULT, 
//		RPC_C_IMP_LEVEL_IMPERSONATE,
//        NULL,
//        EOAC_NONE,
//        NULL
//		);
//	if( FAILED(hres) )
//    {
//		OutputDebugString(L"CoInitializeSecurity Fail");
//		//MessageBox(NULL,L"CoInitializeSecurity Fail",L"error",0);
//       // return -2;
//    }
//    
//	// 获得WMI连接COM接口
//    IWbemLocator *pLoc = NULL;
//    hres = CoCreateInstance( 
//		CLSID_WbemLocator,             
//        NULL, 
//        CLSCTX_INPROC_SERVER, 
//        IID_IWbemLocator,
//		reinterpret_cast<LPVOID*>(&pLoc)
//		); 
//    if( FAILED(hres) )
//    {
//		CoUninitialize();
//		OutputDebugString(L"CoCreateInstance Fail");
//		//MessageBox(NULL,L"CoCreateInstance Fail",L"error",0);
//        return bfunRes;
//    }
//
//    // 通过连接接口连接WMI的内核对象名"ROOT\\CIMV2"
//	IWbemServices *pSvc = NULL;
//	hres = pLoc->ConnectServer(
//         _bstr_t( L"ROOT\\CIMV2" ),
//         NULL,
//         NULL,
//         NULL,
//         0,
//         NULL,
//         NULL,
//         &pSvc
//		 );    
//    if( FAILED(hres) )
//    {
//		pLoc->Release(); 
//        CoUninitialize();
//        return bfunRes;
//    }
//
//	// 设置请求代理的安全级别
//    hres = CoSetProxyBlanket(
//		pSvc,
//		RPC_C_AUTHN_WINNT,
//		RPC_C_AUTHZ_NONE,
//		NULL,
//		RPC_C_AUTHN_LEVEL_CALL,
//		RPC_C_IMP_LEVEL_IMPERSONATE,
//		NULL,
//		EOAC_NONE
//		);
//	if( FAILED(hres) )
//    {
//        pSvc->Release();
//        pLoc->Release();     
//        CoUninitialize();
//        return bfunRes;
//    }
//
//	    // 通过请求代理来向WMI发送请求
//    IEnumWbemClassObject *pEnumerator = NULL;
//
//	//int iQueryType = 0;
//	//for( iQueryType = 0;iQueryType<szWQLQuerySize;iQueryType++)
//	//{
//		
//		/*	T_DEVICE_PROPERTY properties[10];
//		memset(properties,0,sizeof(T_DEVICE_PROPERTY));
//		iTotal = 0;*/
//
//    hres = pSvc->ExecQuery(
//		bstr_t("WQL"), 
//		bstr_t( /*szWQLQuery[iQueryType].szSelect*/ szWQLQuery.selectstr.c_str()),
//        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
//        NULL,
//        &pEnumerator
//		);
//	if( FAILED(hres) )
//    {
//		wchar_t  szBuf[128] = {L"0"};
//		LPVOID lpMsgBuf;
//		FormatMessage (
//			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
//			NULL,
//			hres,
//			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
//			(LPWSTR) &lpMsgBuf,
//			0, NULL );
//
//		wsprintf(szBuf,
//			L"Next  err (err=%0xd): %s",
//			hres, lpMsgBuf);
//		LocalFree(lpMsgBuf);
//
//		OutputDebugString(szBuf);
//
//		//MessageBox(NULL,szBuf,L"ExecQuery Fail",0);
//        pSvc->Release();
//        pLoc->Release();
//        CoUninitialize();
//        return -3;
//    }
//
//    // 循环枚举所有的结果对象  
//    //while( pEnumerator )
//   // {
//		IWbemClassObject *pclsObj = NULL;
//		ULONG uReturn = 0;
//
//		/*if( (properties != NULL) && (iTotal >= iSize) )
//		{
//			break;
//		}*/
//
//        hres = pEnumerator->Next(
//			WBEM_INFINITE,
//			1, 
//            &pclsObj,
//			&uReturn
//			);
//
//        if( uReturn == 0 )
//        {
//			wchar_t  szBuf[128] = {L"0"};
//			LPVOID lpMsgBuf;
//			FormatMessage (
//				FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
//				NULL,
//				hres,
//				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
//				(LPWSTR) &lpMsgBuf,
//				0, NULL );
//
//			wsprintf(szBuf,
//				L"Next  err (err=%0xd): %s",
//				hres, lpMsgBuf);
//			LocalFree(lpMsgBuf);
//
//			OutputDebugString(szBuf);
//			//MessageBox(NULL,szBuf,L"error",0);
//
//			continue;
//           // break;
//        }
//	
//
//		//if( properties != NULL )
//		//{	// 获取属性值
//			VARIANT vtProperty;
//			
//			VariantInit( &vtProperty );	
//			pclsObj->Get( szWQLQuery[iQueryType].szProperty, 0, &vtProperty, NULL, NULL );
//			StringCchCopy( properties[iQueryType].szProperty, PROPERTY_MAX_LEN, W2T(vtProperty.bstrVal) );
//			//StringCchCopy( properties[iTotal].szProperty, PROPERTY_MAX_LEN, W2T(vtProperty.bstrVal) );
//			VariantClear( &vtProperty );
//
//			// 对属性值做进一步的处理
//			if( WMI_DoWithProperty( iQueryType, properties[iQueryType].szProperty, PROPERTY_MAX_LEN ) )
//			{
//				iTotal++;
//			}
//		//}
//		//else
//		//{
//		//	iTotal++;
//		//}
//
//		pclsObj->Release();
//   // } // End While
//	//}
//
//    // 释放资源
//	pEnumerator->Release();
//    pSvc->Release();
//    pLoc->Release();    
//    CoUninitialize();
//
//    return iTotal;
//}






int GetWqlPropertyValue(const T_WQL_QUERY szWQLQuery, int iQueryType, T_DEVICE_PROPERTY *properties,int propertysize)
{
	HRESULT hres;
	INT	iTotal = 0;

    // 初始化COM

    hres = CoInitializeEx( NULL, COINIT_MULTITHREADED ); 
    if( FAILED(hres) )
    {
		OutputDebugStringA("CoInitializeEx Fail");
        return WMI_QUERYPROPERTY_FAIL;
    }

     //设置COM的安全认证级别
	hres = CoInitializeSecurity( 
		NULL, 
		-1, 
		NULL, 
		NULL, 
		RPC_C_AUTHN_LEVEL_DEFAULT, 
		RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL,
        EOAC_NONE,
        NULL
		);
	if( FAILED(hres) )
    {
		OutputDebugString(L"CoInitializeSecurity Fail");
    }
    
	// 获得WMI连接COM接口
    IWbemLocator *pLoc = NULL;
    hres = CoCreateInstance( 
		CLSID_WbemLocator,             
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IWbemLocator,
		reinterpret_cast<LPVOID*>(&pLoc)
		); 
    if( FAILED(hres) )
    {
		CoUninitialize();
		OutputDebugString(L"CoCreateInstance Fail");
        return WMI_QUERYPROPERTY_FAIL;
    }

	IWbemServices *pSvc = NULL;
	hres = pLoc->ConnectServer(
         _bstr_t( L"ROOT\\CIMV2" ),
         NULL,
         NULL,
         NULL,
         0,
         NULL,
         NULL,
         &pSvc
		 );    
    if( FAILED(hres) )
    {
		pLoc->Release(); 
        CoUninitialize();
		OutputDebugString(L"ConnectServer Fail");
        return WMI_QUERYPROPERTY_FAIL;
    }

	// 设置请求代理的安全级别
    hres = CoSetProxyBlanket(
		pSvc,
		RPC_C_AUTHN_WINNT,
		RPC_C_AUTHZ_NONE,
		NULL,
		RPC_C_AUTHN_LEVEL_CALL,
		RPC_C_IMP_LEVEL_IMPERSONATE,
		NULL,
		EOAC_NONE
		);
	if( FAILED(hres) )
    {
		OutputDebugString(L"CoSetProxyBlanket Fail");

        pSvc->Release();
        pLoc->Release();     
        CoUninitialize();
        return WMI_QUERYPROPERTY_FAIL;
    }

	    // 通过请求代理来向WMI发送请求
    IEnumWbemClassObject *pEnumerator = NULL;
    hres = pSvc->ExecQuery(
		bstr_t("WQL"), 
		bstr_t( szWQLQuery.szSelect ),
        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
        NULL,
        &pEnumerator
		);
	if( FAILED(hres) )
    {
		wchar_t  szBuf[128] = {L"0"};
		LPVOID lpMsgBuf;
		FormatMessage (
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			hres,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(LPWSTR) &lpMsgBuf,
			0, NULL );

		  _snwprintf_s(szBuf,sizeof(szBuf),sizeof(szBuf)-1,L"Next  err (err=%0xd): %s",hres, lpMsgBuf);

		OutputDebugString(szBuf);

        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return WMI_QUERYPROPERTY_FAIL;
    }

    // 循环枚举所有的结果对象  
    while( pEnumerator )
    {
		IWbemClassObject *pclsObj = NULL;
		ULONG uReturn = 0;

        hres = pEnumerator->Next(
			WBEM_INFINITE,
			1, 
            &pclsObj,
			&uReturn
			);

        if( uReturn == 0 )
        {
			wchar_t  szBuf[128] = {L"0"};
			LPVOID lpMsgBuf;
			FormatMessage (
				FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				NULL,
				hres,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				(LPWSTR) &lpMsgBuf,
				0, NULL );

			wsprintf(szBuf,
				L"Next  err (err=%0xd): %s",
				hres, lpMsgBuf);
			LocalFree(lpMsgBuf);

			OutputDebugString(szBuf);

			break;
        }
	
		if (propertysize<=iTotal)
		{
			pclsObj->Release();
			break;
		}

		if( properties != NULL )
		{	// 获取属性值
			VARIANT vtProperty;
			
			wchar_t szpropValue[PROPERTY_MAX_LEN] = {L"0"};

			VariantInit( &vtProperty );	
			pclsObj->Get( szWQLQuery.szProperty, 0, &vtProperty, NULL, NULL );
			StringCchCopy( szpropValue, PROPERTY_MAX_LEN, W2T(vtProperty.bstrVal) );
			VariantClear( &vtProperty );

			// 对属性值做进一步的处理
			if( WMIDoWithProperty( iQueryType, szpropValue, PROPERTY_MAX_LEN ) )
			{
				wsprintf(properties[iTotal].szProperty,L"%s",szpropValue);
				OutputDebugString(properties[iTotal].szProperty);
				iTotal++;
			}
		}
		pclsObj->Release();
    } // End While

    // 释放资源
	pEnumerator->Release();
    pSvc->Release();
    pLoc->Release();    
    CoUninitialize();

    return iTotal;
}